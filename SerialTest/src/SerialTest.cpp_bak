//============================================================================
//Name:SerialTest.cpp
//Author:
//Version:
//Copyright:Yourcopyrightnotice
//Description:HelloWorldinC++,Ansi-style
//============================================================================

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include "mavlink/common/mavlink.h"

using namespace std;

//Opened port!
//Link ttyACM0 is connected.
//
//NuttShell (NSH)
//nsh>
//nsh> sh /etc/init.d/rc.usb
//Starting MAVLink on this USB console
//[uorb] already loaded
//uORB started
//
//mavlink: .
//mavlink: terminated.
//stopped other MAVLink instance
//mavlink: MAVLink v1.0 serial interface starting...
//mavlink: DOWNLINK MODE
//mavlink: UART is /dev/ttyACM0, baudrate is 230400
//
//mavlink_uart_rcv: No waypoints send
//mavlink_uart_rcv: Sent waypoint count (0) to ID 255
//commander: .
//commander: terminated.
//Commander stopped
//
//(MAV 001:50) [mavlink pm] sending list
//(MAV 001:50) [cmd] started
//(MAV 001:50) [cmd] arming state: STANDBY
//

// Example variable, by declaring them static they're persistent
// and will thus track the system state

int main(int argc, char** argv) {
	struct termios tio;
	struct termios stdio;
	struct termios old_stdio;
	int tty_fd;

	unsigned char c = 'D';
	if (tcgetattr(STDOUT_FILENO, &old_stdio) != 0) {
		printf("tcgetattr(STDOUT_FILENO, &old_stdio)!= 0");
		return 1;
	}

	memset(&stdio, 0, sizeof(stdio));
	stdio.c_iflag = 0;
	stdio.c_oflag = 0;
	stdio.c_cflag = 0;
	stdio.c_lflag = 0;
	stdio.c_cc[VMIN] = 1;
	stdio.c_cc[VTIME] = 0;
	if (tcsetattr(STDOUT_FILENO, TCSANOW, &stdio) != 0) {
		printf("tcsetattr(STDOUT_FILENO, TCSANOW, &stdio)!= 0");
		return 1;
	}
	//Check if working
	tcsetattr(STDOUT_FILENO, TCSAFLUSH, &stdio);
	fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);

	memset(&tio, 0, sizeof(tio));
	tio.c_iflag = 0;
	tio.c_oflag = 0;
	tio.c_cflag = CS8 | CREAD | CLOCAL; // 8n1, see termios.h for more information
	tio.c_lflag = 0;
	tio.c_cc[VMIN] = 1;
	tio.c_cc[VTIME] = 5;

	tty_fd = open("/dev/ttyACM0", O_RDWR | O_NONBLOCK);
	if (tty_fd == 0) {
		printf("open(\"/dev/ttyACM0\", O_RDWR | O_NONBLOCK)==0");
		return 1;
	}

	if (cfsetospeed(&tio, B115200) != 0) { // 115200 baud
		printf("cfsetospeed(&tio, B115200)!= 0");
		return 1;
	}

	if (cfsetispeed(&tio, B115200) != 0) { // 115200 baud
		printf("cfsetispeed(&tio, B115200)!= 0");
		return 1;
	}

	if (tcsetattr(tty_fd, TCSANOW, &tio) != 0) {
		printf("tcsetattr(tty_fd, TCSANOW, &tio)!= 0");
		return 1;
	}

	char cmd[] = "sh /etc/init.d/rc.usb\n";
	sleep(2);
	while (read(tty_fd, &c, 1) > 0) {
		write(STDOUT_FILENO, &c, 1); // if new data is available on the serial port, print it out
	}
	write(tty_fd, cmd, sizeof(cmd));

	sleep(2);
	while (read(tty_fd, &c, 1) > 0) {
		write(STDOUT_FILENO, &c, 1); // if new data is available on the serial port, print it out
	}

	//close(tty_fd);
	//tcsetattr(STDOUT_FILENO, TCSANOW, &old_stdio);

	//tty_fd = open("/dev/ttyACM0", O_RDWR | O_NONBLOCK);
	//cfsetospeed(&tio, B230400);            // 230400 baud
	//cfsetispeed(&tio, B230400);            // 230400 baud
	//tcsetattr(tty_fd, TCSANOW, &tio);

	mavlink_message_t msg;
	mavlink_status_t status;

	while (true) {
		if (read(tty_fd, &c, 1) > 0) {
			if (mavlink_parse_char(MAVLINK_COMM_0, c, &msg, &status)) {
				// Handle message
				switch (msg.msgid) {
				case MAVLINK_MSG_ID_HEARTBEAT:
					break;
				case MAVLINK_MSG_ID_COMMAND_LONG:
					// EXECUTE ACTION
					break;
				default:
					//Do nothing
					break;
				}
			}

		}
		if (read(STDIN_FILENO, &c, 1) > 0)
			break; // if new data is available on the console, send it to the serial port
	}

	close(tty_fd);
	tcsetattr(STDOUT_FILENO, TCSANOW, &old_stdio);
	return EXIT_SUCCESS;
}
